# dvlad

Work-in-progress Python reimplementation of the DenseVLAD baseline from:
*A. Torii, R. Arandjelović, J. Sivic, M. Okutomi, T. Pajdla — “24/7 Place Recognition by View Synthesis”, CVPR 2015.*

Initial focus: exact replication of Torii15 DenseVLAD pipeline and assets.

## Notes on dependencies

On linux-64, use pixi to build VLFeat from the submodule and install the
clean cyvlfeat submodule:
```
pixi install -e dev
pixi run build-vlfeat-linux
pixi run install-cyvlfeat-linux
pixi run install-dvlad-linux
```
Then load the environment before running tests:
```
source .pixi/vlfeat_env_linux.sh
```

On osx-arm64, the reference workflow uses pixi and the arm64 helper scripts
under `scripts/arm64/` (kept for later):
```
pixi install -e dev
pixi run build-vlfeat-arm64
pixi run install-cyvlfeat-arm64
pixi run install-dvlad-arm64
```

If you are not using pixi, `cyvlfeat` requires the VLFeat C library (headers
and `libvl`) to be installed on your system. On Apple Silicon, build VLFeat
from source with AVX disabled and the SSE2 paths enabled via `sse2neon`,
then set include/library paths when installing `cyvlfeat`.

Example (paths vary):
```
CFLAGS="-I/path/to/vlfeat" LDFLAGS="-L/path/to/vlfeat/bin/maci64" \
  pip install cyvlfeat
```

For Apple Silicon without Rosetta, `scripts/arm64/build_vlfeat_arm64.sh` can
build `libvl` with `sse2neon` and print the environment variables needed to
install `cyvlfeat`. This is reference-only and not part of the default
linux/x86 path.

If you cloned without submodules:
```
git submodule update --init --recursive
```

The repo also includes a clean `thirdparty/cyvlfeat` submodule pinned at
v0.7.1 for reference. The default workflow still installs `cyvlfeat` from
PyPI; no local patches are required for correctness. An optional reference
patch lives at `scripts/reference/cyvlfeat/patch_cyvlfeat_sdist.py` and adds
C-level permute/contrast handling for faster PHOW, but it is not used by
default. To apply it in the arm64 helper, set `DVLAD_PATCH_CYVLFEAT=1`.

To force exact scalar math (used by strict parity tests), set:
`DVLAD_DISABLE_SIMD=1`.

## Parity status

Stage-by-stage parity against MATLAB dumps is exact for:
- preprocessing (downscale + grayscale)
- imsmooth
- DSIFT (all scales)
- PHOW concatenation
- RootSIFT
- kd-tree assignments
- grid masking (example_grid)

Remaining parity checks:
- PCA/whitening vector vs pinned golden vector

## Example asset

`example_gsv` is the example Google Street View image shipped with the
authors' `247code.zip` and used by `test_densevlad.m`:
`247code/data/example_gsv/L-NLvGeZ6JHX6JO8Xnf_BA_012_000.jpg`.

Note: the shipped `example_gsv` and `example_grid` `.dict_grid.dnsvlad.mat`
files do not match the MATLAB code outputs in this environment
(R2025b + VLFeat 0.9.20). The MATLAB outputs differ by:
- example_gsv: 254 elements > 1e-4, max diff ~0.021669
- example_grid: 9370 elements > 1e-4, max diff ~0.020278

## Shipped `.mat` mismatch investigation

We attempted to reproduce the shipped `*.dict_grid.dnsvlad.mat` vectors exactly.
Current Python matches MATLAB (R2025b + VLFeat 0.9.20) stage-for-stage, but
the shipped `.mat` files differ:
- example_gsv `_012_000`: mean |Δ| ~8.33e-5, L2 diff ~0.108, cosine ~0.994,
  max |Δ| ~0.0217, 254 dims > 1e-4 (differences concentrated in 2 clusters).
- example_grid `_012_000`: mean |Δ| ~4.18e-4, L2 diff ~0.150, cosine ~0.989,
  max |Δ| ~0.0203, 9370 dims > 1e-4.

Variants tested (none matched the shipped vectors):
- VLFeat 0.9.19 vs 0.9.20, arm64 build vs x86_64 (Rosetta) binary.
- PHOW options (fast/float, step), bounds offsets, magnification/window size,
  contrast threshold, quantization path.
- kd-tree vs brute assignments; float32 vs float64 normalization.
- grid masking variants (dilation, center-only, multi-sample, plane/no-plane).

Conclusion: the shipped `.mat` files were likely generated in a different
environment (e.g., MATLAB R2015a/2013b on Intel, or a different VLFeat build
or grid masking variant). For exact shipped parity, we need the original
environment or intermediate dumps from the authors' setup.

## MATLAB dump (strict tests)

The stage parity tests require a MATLAB dump generated by
`scripts/matlab/dump_densevlad.m`. It writes:
`~/Library/Caches/dvlad/torii15/matlab_dump/densevlad_dump.mat`.

Masked grid parity uses:
`scripts/matlab/dump_densevlad_grid.m`, which writes:
`~/Library/Caches/dvlad/torii15/matlab_dump/densevlad_grid_dump.mat`.

Tokyo247 golden references use:
`scripts/matlab/dump_tokyo247_golden.m`, which writes:
- `~/Library/Caches/dvlad/torii15/matlab_dump/tokyo247_golden.mat`
- `~/Library/Caches/dvlad/torii15/matlab_dump/tokyo247_golden_list.txt`

The golden set samples 5 DB + 5 query images (seed 1337), resizes to max 640
pixels (paper setting), and stores both pre-PCA VLAD (16384-D) and
PCA-whitened VLAD (4096-D) for parity tests.

The repo ships a MATLAB-normalized centers asset at:
`src/dvlad/torii15/data/dnscnt_RDSIFT_K128.cx_norm.npy`.
This is the exact `CX` after MATLAB normalization, so kd-tree assignments
match bit-for-bit without a local cache.

Dense assignment defaults to `matmul` (vectorized exact L2 with deterministic
zero-descriptor tie handling) and is usually identical to kd-tree, but rare
tie cases can differ. For strict parity tests and paper matching, use
`DVLAD_ASSIGN_METHOD=kdtree`. For an alternative fast path that may diverge,
set `DVLAD_ASSIGN_METHOD=kmeans`. The matmul block size can be tuned with
`DVLAD_MATMUL_BLOCK` (default 8192).

## Performance notes

Tokyo247 golden (10 images, max_dim=640, imdown=false), Apple Silicon, single
core, NEON enabled:
```
stage         Python kdtree   Python matmul
read          0.108 s         0.109 s
phow          0.076 s         0.076 s
rootsift      0.041 s         0.040 s
assignment    1.810 s         0.205 s
vlad          0.006 s         0.005 s
total         2.040 s         0.435 s
```
PHOW is ~5x faster than the original baseline after NEON dsift + C-level
permutation/contrast thresholding. The kd-tree query still dominates the
exact path. The matmul path (BLAS) cuts assignment time by ~9x and delivers
~4.7x end-to-end speedup, but can differ in rare tie cases (observed
1 descriptor mismatch out of 10 golden images, max VLAD diff ~5.5e-05).
Use `DVLAD_ASSIGN_METHOD=kdtree` for strict parity.

To regenerate or verify the shipped asset from a local MATLAB dump:
```
pixi run -e dev python scripts/generate_cx_norm.py --verify
```

If you generate a dump locally, the same normalized `CX` is also cached at:
`~/Library/Caches/dvlad/torii15/247code/data/dnscnt_RDSIFT_K128.cx_norm.npy`.

## Validation pipeline (end-to-end)

This is the full validation workflow used to assert parity.

1) **Fetch assets**
- The code downloads `247code.zip` from the authors to
  `~/Library/Caches/dvlad/torii15/247code.zip` on first use.
- Tests and scripts use `Torii15Assets.default()` to pull files from the zip
  into `~/Library/Caches/dvlad/torii15/247code/...`.

2) **Build VLFeat + cyvlfeat**
- Linux (pixi):
```
pixi install -e dev
pixi run build-vlfeat-linux
pixi run install-cyvlfeat-linux
pixi run install-dvlad-linux
```
- Apple Silicon (pixi, reference-only):
```
pixi install -e dev
pixi run build-vlfeat-arm64
pixi run install-cyvlfeat-arm64
pixi run install-dvlad-arm64
```
- Ensure `libvl` is discoverable before running tests:
```
source .pixi/vlfeat_env_linux.sh
```
or (arm64 reference):
```
source .pixi/vlfeat_env.sh
```

3) **Generate MATLAB dumps**
- DenseVLAD baseline (example_gsv):
```
/Applications/MATLAB_R2025b.app/bin/matlab -batch "run('scripts/matlab/dump_densevlad.m')"
```
- DenseVLAD with grid masking (example_grid):
```
/Applications/MATLAB_R2025b.app/bin/matlab -batch "run('scripts/matlab/dump_densevlad_grid.m')"
```
- Outputs:
  - `~/Library/Caches/dvlad/torii15/matlab_dump/densevlad_dump.mat`
  - `~/Library/Caches/dvlad/torii15/matlab_dump/densevlad_grid_dump.mat`

4) **Stage-by-stage parity tests (strict, exact match)**
- Covers preprocessing, imsmooth, DSIFT per scale, PHOW concat, RootSIFT,
  kd-tree assignments, and grid mask.
```
source .pixi/vlfeat_env.sh
python -m pytest tests/test_torii15_stage_parity.py -q
```
- Tests read MATLAB v7.3 dumps via `h5py` and use exact array equality.

5) **Pre-PCA VLAD parity tests**
- Compares Python DenseVLAD against the MATLAB dumps for:
  - example_gsv `_012_000`
  - example_grid `_012_000` (masked)
```
source .pixi/vlfeat_env.sh
python -m pytest tests/test_torii15_pre_pca_vlad.py -q
```

6) **Whitening (golden vector)**
- Uses the shipped PCA assets plus a pinned golden DenseVLAD vector
  (base64 in `tests/test_torii15_whitening.py`) to avoid loading the ~1GB
  PCA matrix in unit tests.
```
python -m pytest tests/test_torii15_whitening.py -q
```

7) **Shipped `.dict_grid.dnsvlad.mat` comparison (informational)**
- We do *not* use the shipped `.mat` files for parity tests because they do not
  match MATLAB outputs in this environment; see the “Shipped `.mat` mismatch
  investigation” section for metrics and attempted fixes.

## MATLAB baseline (Tokyo 24/7)

To run the baseline in MATLAB (without Image Processing Toolbox), use:
```
/Applications/MATLAB_R2025b.app/bin/matlab -batch \
  "addpath('scripts/matlab'); eval_tokyo247_densevlad('limit_db',10,'limit_q',5,'force',true)"
```

This uses `scripts/matlab/im2single.m` as a fallback so the code runs
without the toolbox. Remove the limits for a full run (note: this is
slow; DenseVLAD is ~30s/image on CPU in MATLAB).

By default the MATLAB evaluator resizes images to max dimension 640 and
does not apply `vl_imdown`. You can override these with:
`'max_dim', 0` (disable resize) and `'use_imdown', true`.

## Tokyo 24/7 baseline evaluation (Figure 6)

This reproduces the DenseVLAD baseline recall@N on the 24/7-Tokyo dataset
using the query subset from the paper (315 images).

### Dataset downloads

Database images (GSV) and queries are mirrored by the NetVLAD project:
`https://data.ciirc.cvut.cz/public/projects/2015netVLAD/Tokyo247/`.

1) **Database (75,984 images, ~40GB)**
Download all `03814.tar` ... `03829.tar` from:
`https://data.ciirc.cvut.cz/public/projects/2015netVLAD/Tokyo247/database_gsv_vga/`
and extract into:
`~/Library/Caches/dvlad/torii15/tokyo247/database_gsv_vga/03814/...`

2) **Query subset (1.1GB, 315 images)**
`https://data.ciirc.cvut.cz/public/projects/2015netVLAD/Tokyo247/queries/247query_subset_v2.zip`
Extract to:
`~/Library/Caches/dvlad/torii15/247query_subset_v2/247query_subset_v2/`

3) **dbStruct metadata (tokyo247.mat)**
Download the NetVLAD-compatible dbStruct file:
```
curl -L -o ~/Library/Caches/dvlad/torii15/tokyo247/tokyo247.mat \
  https://raw.githubusercontent.com/devanshigarg01/pittsburghdata/main/tokyo247.mat
```

The dbStruct lists `.jpg` paths, but the database is shipped as `.png`;
the evaluator maps `.jpg` -> `.png` automatically.

### Run DenseVLAD baseline

```
source .pixi/vlfeat_env.sh
python scripts/eval_tokyo247_densevlad.py
```

Descriptor caches are stored at:
`~/Library/Caches/dvlad/torii15/tokyo247/densevlad_cache/`.

The evaluator resizes images so the maximum dimension is 640 by default
(`--max-dim 640`), matching the paper. Use `--use-imdown` to append the
extra `vl_imdown` step from the released MATLAB code.

Descriptor extraction supports parallel workers. By default the evaluator
uses up to 4 processes; override with `--workers N` (and optionally
`--worker-chunksize` for task batching).

You can override dataset locations via:
`DVLAD_TOKYO247_ROOT`, `DVLAD_TOKYO247_DB_DIR`,
`DVLAD_TOKYO247_QUERY_DIR`, and `DVLAD_TOKYO247_DBSTRUCT`.
